{% extends "base.html" %}

{% block libs %}
    {{ super() }}

    <script type="text/javascript">
        window.MathJax = {
            tex: {
                inlineMath: [['$', '$'], ['\\(', '\\)']],  // 支持 $...$ 和 \(...\) 语法
                displayMath: [['$$', '$$'], ['\\[', '\\]']],
            },
            options: {
                processEscapes: true
            }
        };
    </script>

    <script type="text/javascript" id="MathJax-script" async
        src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>

    <!-- 背景圖片 -->
    <div class="image-background"></div>

    <!-- 粒子效果的Canvas背景，放置在背景圖片前面 -->
    <canvas id="particleCanvas" style="z-index: -1; position: fixed; top: 0; left: 0; width: 100%; height: 100%;"></canvas>

    <script>
      document.addEventListener("DOMContentLoaded", function() {
        var particleCanvas = document.getElementById('particleCanvas');
        var particleCtx = particleCanvas.getContext('2d');
    
        function resizeParticleCanvas() {
          particleCanvas.width = window.innerWidth;
          particleCanvas.height = window.innerHeight;
        }
        resizeParticleCanvas();
        window.addEventListener('resize', resizeParticleCanvas);
    
        class Sakura {
          constructor(x, y) {
            this.x = x;
            this.y = y;
            this.size = Math.random() * 1.5 + 1;
            this.speedY = Math.random() * 2 + 0.1;
            this.speedX = Math.random() * 2 - 1;
            this.alpha = Math.random() * 0.8 + 0.2;
            this.angle = Math.random() * Math.PI * 2;
            this.angleSpeed = Math.random() * 0.05;
          }
    
          update() {
            this.y += this.speedY;
            this.x += this.speedX;
            this.angle += this.angleSpeed;
            // 如果櫻花超出畫布底部，將其從粒子數組中移除
            if (this.y > particleCanvas.height) {
              particlesArray.splice(particlesArray.indexOf(this), 1);
            }
            if (this.x > particleCanvas.width || this.x < 0) {
              this.speedX *= -1;
            }
          }
    
          draw() {
            particleCtx.save();
            particleCtx.translate(this.x, this.y);
            particleCtx.rotate(this.angle);
            particleCtx.fillStyle = `rgba(255, 182, 193, ${this.alpha})`;
            particleCtx.beginPath();
            particleCtx.moveTo(0, 0);
            for (let i = 0; i < 5; i++) {
              particleCtx.ellipse(
                this.size * 0.8 * Math.cos((i * 2 * Math.PI) / 5),
                this.size * 1.2 * Math.sin((i * 2 * Math.PI) / 5),
                this.size * 0.8, this.size * 1.2,
                Math.random() * 0.3, 0, 2 * Math.PI
              );
            }
            particleCtx.closePath();
            particleCtx.fill();
            particleCtx.restore();
          }
        }
    
        let particlesArray = [];
    
        // 每次固定間隔時間生成一個新的櫻花
        function generateFixedRateSakura() {
          if (particlesArray.length < 300) {  // 限制粒子數量
            const x = Math.random() * particleCanvas.width;
            const y = -10;  // 櫻花從畫布上方生成
            particlesArray.push(new Sakura(x, y));
          }
        }
    
        // 滑鼠移動時生成新的櫻花
        function createMouseSakura(event) {
          if (particlesArray.length < 300) {  // 限制粒子數量
            const x = event.x;
            const y = event.y;
            particlesArray.push(new Sakura(x, y));
          }
        }
    
        function connectParticles() {
          let maxDistance = 100;
          for (let a = 0; a < particlesArray.length; a++) {
            for (let b = a + 1; b < particlesArray.length; b++) {
              let dx = particlesArray[a].x - particlesArray[b].x;
              let dy = particlesArray[a].y - particlesArray[b].y;
              let distance = Math.sqrt(dx * dx + dy * dy);
              if (distance < maxDistance) {
                let opacity = 1 - distance / maxDistance;
                particleCtx.strokeStyle = `rgba(255, 182, 193, ${opacity})`;
                particleCtx.lineWidth = 1;
                particleCtx.beginPath();
                particleCtx.moveTo(particlesArray[a].x, particlesArray[a].y);
                particleCtx.lineTo(particlesArray[b].x, particlesArray[b].y);
                particleCtx.stroke();
              }
            }
          }
        }
    
        function handleParticles() {
          for (let i = 0; i < particlesArray.length; i++) {
            particlesArray[i].update();
            particlesArray[i].draw();
          }
        }
    
        function animate() {
          particleCtx.clearRect(0, 0, particleCanvas.width, particleCanvas.height);
          handleParticles();
          connectParticles();
          requestAnimationFrame(animate);
        }
    
        // 開始動畫循環
        animate();
    
        // 以固定間隔（例如每100毫秒）生成櫻花
        setInterval(generateFixedRateSakura, 100);  // 每100毫秒生成一個櫻花
    
        // 監聽滑鼠移動事件來生成櫻花
        window.addEventListener('mousemove', createMouseSakura);
    
        var tocContainer = document.querySelector('.custom-toc-container');
        var contentInner = document.querySelector('.md-content__inner');
        if (contentInner && tocContainer) {
            updateTocPosition();
            tocContainer.addEventListener('click', function() {
                tocContainer.classList.toggle('expanded');
            });
        }
    
        function updateTocPosition() {
            var contentInnerRect = contentInner.getBoundingClientRect();
            tocContainer.style.top = contentInnerRect.top + 'px';
            tocContainer.style.left = contentInnerRect.right - 100 + 25 + 'px';
        }
    
        document.querySelectorAll('img').forEach(function(img) {
            const match = img.src.match(/=(\d+)%x$/);
            if (match) {
                const widthPercentage = match[1];
                img.style.width = widthPercentage + '%';
                img.style.height = 'auto';
                img.src = img.src.replace(/=(\d+)%x$/, '');
            }
        });
      });
    </script>
    
{% endblock %}

{% block content %}
<div class="md-content__inner">
    {{ super() }}
    <!-- 新增的 TOC 區塊，引用 toc 擴展生成的永久鏈接 -->
    <div class="custom-toc-container">
        <div class="custom-toc-title">目錄</div>
        <nav class="custom-toc">
            <ul>
                {% for section in page.toc %}
                <li>
                    <a href="#{{ section.id }}">{{ section.title }}</a>
                    {% if section.children %}
                    <ul>
                        {% for child in section.children %}
                        <li>
                            <a href="#{{ child.id }}">{{ child.title }}</a>
                            {% if child.children %}
                            <ul>
                                {% for grandchild in child.children %}
                                <li>
                                    <a href="#{{ grandchild.id }}">{{ grandchild.title }}</a>
                                </li>
                                {% endfor %}
                            </ul>
                            {% endif %}
                        </li>
                        {% endfor %}
                    </ul>
                    {% endif %}
                </li>
                {% endfor %}
            </ul>
        </nav>
    </div>
</div>
{% endblock %}
